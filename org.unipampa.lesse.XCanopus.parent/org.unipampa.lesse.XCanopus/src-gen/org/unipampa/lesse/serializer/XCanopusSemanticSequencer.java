/*
 * generated by Xtext 2.16.0
 */
package org.unipampa.lesse.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.unipampa.lesse.services.XCanopusGrammarAccess;
import org.unipampa.lesse.xCanopus.Main;
import org.unipampa.lesse.xCanopus.MetricModel;
import org.unipampa.lesse.xCanopus.Model;
import org.unipampa.lesse.xCanopus.SCENARIO;
import org.unipampa.lesse.xCanopus.SUT;
import org.unipampa.lesse.xCanopus.XCanopusPackage;
import org.unipampa.lesse.xCanopus.and_atleast;
import org.unipampa.lesse.xCanopus.and_the_metric;
import org.unipampa.lesse.xCanopus.and_the_scenario;
import org.unipampa.lesse.xCanopus.and_workload;
import org.unipampa.lesse.xCanopus.given;
import org.unipampa.lesse.xCanopus.then;
import org.unipampa.lesse.xCanopus.when;

@SuppressWarnings("all")
public class XCanopusSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private XCanopusGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == XCanopusPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XCanopusPackage.MAIN:
				sequence_Main(context, (Main) semanticObject); 
				return; 
			case XCanopusPackage.METRIC_MODEL:
				sequence_MetricModel(context, (MetricModel) semanticObject); 
				return; 
			case XCanopusPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case XCanopusPackage.SCENARIO:
				sequence_SCENARIO(context, (SCENARIO) semanticObject); 
				return; 
			case XCanopusPackage.SUT:
				sequence_SUT(context, (SUT) semanticObject); 
				return; 
			case XCanopusPackage.AND_ATLEAST:
				sequence_and_atleast(context, (and_atleast) semanticObject); 
				return; 
			case XCanopusPackage.AND_THE_METRIC:
				sequence_and_the_metric(context, (and_the_metric) semanticObject); 
				return; 
			case XCanopusPackage.AND_THE_SCENARIO:
				sequence_and_the_scenario(context, (and_the_scenario) semanticObject); 
				return; 
			case XCanopusPackage.AND_WORKLOAD:
				sequence_and_workload(context, (and_workload) semanticObject); 
				return; 
			case XCanopusPackage.GIVEN:
				sequence_given(context, (given) semanticObject); 
				return; 
			case XCanopusPackage.THEN:
				sequence_then(context, (then) semanticObject); 
				return; 
			case XCanopusPackage.WHEN:
				sequence_when(context, (when) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Main returns Main
	 *
	 * Constraint:
	 *     (main+=MetricModel | main+=SCENARIO | main+=SUT)
	 */
	protected void sequence_Main(ISerializationContext context, Main semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetricModel returns MetricModel
	 *
	 * Constraint:
	 *     (name=ID steps+=STEPS+)
	 */
	protected void sequence_MetricModel(ISerializationContext context, MetricModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     main+=Main+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SCENARIO returns SCENARIO
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SCENARIO(ISerializationContext context, SCENARIO semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XCanopusPackage.Literals.SCENARIO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XCanopusPackage.Literals.SCENARIO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSCENARIOAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SUT returns SUT
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SUT(ISerializationContext context, SUT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XCanopusPackage.Literals.SUT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XCanopusPackage.Literals.SUT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSUTAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     STEPS returns and_atleast
	 *     and_atleast returns and_atleast
	 *
	 * Constraint:
	 *     (integer1=INT integer2=INT)
	 */
	protected void sequence_and_atleast(ISerializationContext context, and_atleast semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XCanopusPackage.Literals.AND_ATLEAST__INTEGER1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XCanopusPackage.Literals.AND_ATLEAST__INTEGER1));
			if (transientValues.isValueTransient(semanticObject, XCanopusPackage.Literals.AND_ATLEAST__INTEGER2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XCanopusPackage.Literals.AND_ATLEAST__INTEGER2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnd_atleastAccess().getInteger1INTTerminalRuleCall_2_0(), semanticObject.getInteger1());
		feeder.accept(grammarAccess.getAnd_atleastAccess().getInteger2INTTerminalRuleCall_4_0(), semanticObject.getInteger2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     STEPS returns and_the_metric
	 *     and_the_metric returns and_the_metric
	 *
	 * Constraint:
	 *     (metric=METRICTYPE integer1=INT integer2=INT integer3=INT?)
	 */
	protected void sequence_and_the_metric(ISerializationContext context, and_the_metric semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     STEPS returns and_the_scenario
	 *     and_the_scenario returns and_the_scenario
	 *
	 * Constraint:
	 *     scenario=[SCENARIO|ID]
	 */
	protected void sequence_and_the_scenario(ISerializationContext context, and_the_scenario semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XCanopusPackage.Literals.AND_THE_SCENARIO__SCENARIO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XCanopusPackage.Literals.AND_THE_SCENARIO__SCENARIO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnd_the_scenarioAccess().getScenarioSCENARIOIDTerminalRuleCall_2_0_1(), semanticObject.eGet(XCanopusPackage.Literals.AND_THE_SCENARIO__SCENARIO, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     STEPS returns and_workload
	 *     and_workload returns and_workload
	 *
	 * Constraint:
	 *     (sut1=[SUT|ID] suttype=SUT_TYPE sut2=[SUT|ID])
	 */
	protected void sequence_and_workload(ISerializationContext context, and_workload semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XCanopusPackage.Literals.AND_WORKLOAD__SUT1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XCanopusPackage.Literals.AND_WORKLOAD__SUT1));
			if (transientValues.isValueTransient(semanticObject, XCanopusPackage.Literals.AND_WORKLOAD__SUTTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XCanopusPackage.Literals.AND_WORKLOAD__SUTTYPE));
			if (transientValues.isValueTransient(semanticObject, XCanopusPackage.Literals.AND_WORKLOAD__SUT2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XCanopusPackage.Literals.AND_WORKLOAD__SUT2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnd_workloadAccess().getSut1SUTIDTerminalRuleCall_2_0_1(), semanticObject.eGet(XCanopusPackage.Literals.AND_WORKLOAD__SUT1, false));
		feeder.accept(grammarAccess.getAnd_workloadAccess().getSuttypeSUT_TYPEEnumRuleCall_4_0(), semanticObject.getSuttype());
		feeder.accept(grammarAccess.getAnd_workloadAccess().getSut2SUTIDTerminalRuleCall_6_0_1(), semanticObject.eGet(XCanopusPackage.Literals.AND_WORKLOAD__SUT2, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     STEPS returns given
	 *     given returns given
	 *
	 * Constraint:
	 *     (sut1=[SUT|ID] suttype=SUT_TYPE sut2=[SUT|ID])
	 */
	protected void sequence_given(ISerializationContext context, given semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XCanopusPackage.Literals.GIVEN__SUT1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XCanopusPackage.Literals.GIVEN__SUT1));
			if (transientValues.isValueTransient(semanticObject, XCanopusPackage.Literals.GIVEN__SUTTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XCanopusPackage.Literals.GIVEN__SUTTYPE));
			if (transientValues.isValueTransient(semanticObject, XCanopusPackage.Literals.GIVEN__SUT2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XCanopusPackage.Literals.GIVEN__SUT2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGivenAccess().getSut1SUTIDTerminalRuleCall_2_0_1(), semanticObject.eGet(XCanopusPackage.Literals.GIVEN__SUT1, false));
		feeder.accept(grammarAccess.getGivenAccess().getSuttypeSUT_TYPEEnumRuleCall_3_0(), semanticObject.getSuttype());
		feeder.accept(grammarAccess.getGivenAccess().getSut2SUTIDTerminalRuleCall_5_0_1(), semanticObject.eGet(XCanopusPackage.Literals.GIVEN__SUT2, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     STEPS returns then
	 *     then returns then
	 *
	 * Constraint:
	 *     (metric=METRICTYPE integer1=INT integer2=INT integer3=INT?)
	 */
	protected void sequence_then(ISerializationContext context, then semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     STEPS returns when
	 *     when returns when
	 *
	 * Constraint:
	 *     metrictype=METRICTYPEMONITORED
	 */
	protected void sequence_when(ISerializationContext context, when semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XCanopusPackage.Literals.WHEN__METRICTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XCanopusPackage.Literals.WHEN__METRICTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhenAccess().getMetrictypeMETRICTYPEMONITOREDEnumRuleCall_2_0(), semanticObject.getMetrictype());
		feeder.finish();
	}
	
	
}
