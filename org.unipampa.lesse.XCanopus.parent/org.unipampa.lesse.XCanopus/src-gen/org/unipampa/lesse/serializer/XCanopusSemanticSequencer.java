/*
 * generated by Xtext 2.15.0
 */
package org.unipampa.lesse.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.unipampa.lesse.services.XCanopusGrammarAccess;
import org.unipampa.lesse.xCanopus.Criteria;
import org.unipampa.lesse.xCanopus.Disk;
import org.unipampa.lesse.xCanopus.Disk_IO_Counter;
import org.unipampa.lesse.xCanopus.Include;
import org.unipampa.lesse.xCanopus.LoadGenerator;
import org.unipampa.lesse.xCanopus.Memory;
import org.unipampa.lesse.xCanopus.MemoryCounter;
import org.unipampa.lesse.xCanopus.MetricModel;
import org.unipampa.lesse.xCanopus.Model;
import org.unipampa.lesse.xCanopus.Monitor;
import org.unipampa.lesse.xCanopus.Monitoring;
import org.unipampa.lesse.xCanopus.SUT;
import org.unipampa.lesse.xCanopus.Threshold;
import org.unipampa.lesse.xCanopus.Transaction;
import org.unipampa.lesse.xCanopus.TransactionCounter;
import org.unipampa.lesse.xCanopus.XCanopusPackage;

@SuppressWarnings("all")
public class XCanopusSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private XCanopusGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == XCanopusPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XCanopusPackage.CRITERIA:
				sequence_Criteria(context, (Criteria) semanticObject); 
				return; 
			case XCanopusPackage.DISK:
				sequence_Disk(context, (Disk) semanticObject); 
				return; 
			case XCanopusPackage.DISK_IO_COUNTER:
				sequence_Disk_IO_Counter(context, (Disk_IO_Counter) semanticObject); 
				return; 
			case XCanopusPackage.INCLUDE:
				sequence_Include(context, (Include) semanticObject); 
				return; 
			case XCanopusPackage.LOAD_GENERATOR:
				sequence_LoadGenerator(context, (LoadGenerator) semanticObject); 
				return; 
			case XCanopusPackage.MEMORY:
				sequence_Memory(context, (Memory) semanticObject); 
				return; 
			case XCanopusPackage.MEMORY_COUNTER:
				sequence_MemoryCounter(context, (MemoryCounter) semanticObject); 
				return; 
			case XCanopusPackage.METRIC_MODEL:
				sequence_MetricModel(context, (MetricModel) semanticObject); 
				return; 
			case XCanopusPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case XCanopusPackage.MONITOR:
				sequence_Monitor(context, (Monitor) semanticObject); 
				return; 
			case XCanopusPackage.MONITORING:
				sequence_Monitoring(context, (Monitoring) semanticObject); 
				return; 
			case XCanopusPackage.SUT:
				sequence_SUT(context, (SUT) semanticObject); 
				return; 
			case XCanopusPackage.THRESHOLD:
				sequence_Threshold(context, (Threshold) semanticObject); 
				return; 
			case XCanopusPackage.TRANSACTION:
				sequence_Transaction(context, (Transaction) semanticObject); 
				return; 
			case XCanopusPackage.TRANSACTION_COUNTER:
				sequence_TransactionCounter(context, (TransactionCounter) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Criteria returns Criteria
	 *
	 * Constraint:
	 *     value=EInt?
	 */
	protected void sequence_Criteria(ISerializationContext context, Criteria semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Metric returns Disk
	 *     Disk returns Disk
	 *
	 * Constraint:
	 *     (name=EString disk_io_counter=[Disk_IO_Counter|EString]?)
	 */
	protected void sequence_Disk(ISerializationContext context, Disk semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Counter returns Disk_IO_Counter
	 *     Disk_IO_Counter returns Disk_IO_Counter
	 *
	 * Constraint:
	 *     (name=EString (counterDisk+=COUNTER_DISK counterDisk+=COUNTER_DISK*)?)
	 */
	protected void sequence_Disk_IO_Counter(ISerializationContext context, Disk_IO_Counter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Include returns Include
	 *
	 * Constraint:
	 *     (importURI=STRING name=ID)
	 */
	protected void sequence_Include(ISerializationContext context, Include semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XCanopusPackage.Literals.INCLUDE__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XCanopusPackage.Literals.INCLUDE__IMPORT_URI));
			if (transientValues.isValueTransient(semanticObject, XCanopusPackage.Literals.INCLUDE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XCanopusPackage.Literals.INCLUDE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIncludeAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.accept(grammarAccess.getIncludeAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LoadGenerator returns LoadGenerator
	 *
	 * Constraint:
	 *     (
	 *         isMonitor?='isMonitor'? 
	 *         hostname=EString? 
	 *         ip=EString? 
	 *         hardware=HARDWARE? 
	 *         (sut+=[SUT|EString] sut+=[SUT|EString]*)? 
	 *         metricmodel=[MetricModel|EString]? 
	 *         monitor=[Monitor|EString]?
	 *     )
	 */
	protected void sequence_LoadGenerator(ISerializationContext context, LoadGenerator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Counter returns MemoryCounter
	 *     MemoryCounter returns MemoryCounter
	 *
	 * Constraint:
	 *     (name=EString (counterMemory+=COUNTER_MEMORY counterMemory+=COUNTER_MEMORY*)?)
	 */
	protected void sequence_MemoryCounter(ISerializationContext context, MemoryCounter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Metric returns Memory
	 *     Memory returns Memory
	 *
	 * Constraint:
	 *     (name=EString memoryCounter=[MemoryCounter|EString]?)
	 */
	protected void sequence_Memory(ISerializationContext context, Memory semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetricModel returns MetricModel
	 *
	 * Constraint:
	 *     (
	 *         memory=Memory? 
	 *         disk=Disk? 
	 *         (criteria+=Criteria criteria+=Criteria*)? 
	 *         (threshold+=Threshold threshold+=Threshold*)? 
	 *         diskCounter=Disk_IO_Counter? 
	 *         transactionCounter=TransactionCounter? 
	 *         memoryCounter=MemoryCounter? 
	 *         (metric+=Metric metric+=Metric*)? 
	 *         (counter+=Counter counter+=Counter*)?
	 *     )
	 */
	protected void sequence_MetricModel(ISerializationContext context, MetricModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         (includes+=Include+ ((monitorings+=Monitoring+ loadGenerators+=LoadGenerator+) | loadGenerators+=LoadGenerator+)) | 
	 *         (((includes+=Include+ monitorings+=Monitoring+) | monitorings+=Monitoring+)? suts+=SUT+ loadGenerators+=LoadGenerator+) | 
	 *         (monitorings+=Monitoring+ loadGenerators+=LoadGenerator+) | 
	 *         loadGenerators+=LoadGenerator+
	 *     )?
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Monitor returns Monitor
	 *
	 * Constraint:
	 *     (hostname=EString? ip=EString? hardware=HARDWARE? (sut+=[SUT|EString] sut+=[SUT|EString]*)?)
	 */
	protected void sequence_Monitor(ISerializationContext context, Monitor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Monitoring returns Monitoring
	 *
	 * Constraint:
	 *     {Monitoring}
	 */
	protected void sequence_Monitoring(ISerializationContext context, Monitoring semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SUT returns SUT
	 *
	 * Constraint:
	 *     (
	 *         hostname=EString? 
	 *         ip=EString? 
	 *         hardware=HARDWARE? 
	 *         type=SUT_TYPE? 
	 *         (sut+=[SUT|EString] sut+=[SUT|EString]*)? 
	 *         metricmodel=[MetricModel|EString]?
	 *     )
	 */
	protected void sequence_SUT(ISerializationContext context, SUT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Threshold returns Threshold
	 *
	 * Constraint:
	 *     value=EInt?
	 */
	protected void sequence_Threshold(ISerializationContext context, Threshold semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Counter returns TransactionCounter
	 *     TransactionCounter returns TransactionCounter
	 *
	 * Constraint:
	 *     (name=EString (counterTransaction+=COUNTER_TRANSACTION counterTransaction+=COUNTER_TRANSACTION*)?)
	 */
	protected void sequence_TransactionCounter(ISerializationContext context, TransactionCounter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Transaction returns Transaction
	 *
	 * Constraint:
	 *     (name=EString transactionCounter=[TransactionCounter|EString]?)
	 */
	protected void sequence_Transaction(ISerializationContext context, Transaction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
